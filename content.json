{"meta":{"title":"Fantacy","subtitle":null,"description":null,"author":"Fantacy-Xu","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-06-05T08:57:52.000Z","updated":"2019-06-05T08:58:38.870Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2019-06-05T02:34:09.000Z","updated":"2019-06-05T03:55:04.652Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"联系方式 Email：535137339@qq.com QQ：535137339 个人信息 许少锋/男/1997 技术博客：https://github.com/fantacy-Xu Github：https://github.com/fantacy-Xu 自我简介 对前端技术具有浓厚的兴趣，享受coding，喜欢逛掘金，博客园，知乎等论坛； 爱好游戏，主机游戏/网络游戏/手机游戏都有涉及； 小说轻度爱好者，平时无聊会看一些玄幻小说或名著，涉猎广泛； 性格随和，平时话语偏少，熟人之间话语相对较多。"},{"title":"tags","date":"2019-06-05T09:01:43.000Z","updated":"2019-06-05T09:02:02.665Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"闭包","slug":"closure","date":"2019-06-03T08:54:45.000Z","updated":"2019-06-05T07:32:03.176Z","comments":true,"path":"2019/06/03/closure/","link":"","permalink":"http://yoursite.com/2019/06/03/closure/","excerpt":"","text":"闭包 什么是闭包 闭包：是指有权访问其他函数中局部变量的函数。 闭包作用 先看下面一段代码：12345678910function A()&#123; var a = 10; // 局部变量a function B()&#123; console.log(a); // 10 &#125; return B; // 最后返回函数B,函数B就是我们的闭包&#125;var result = A(); // result就是整个B函数result(); // 解释： 由于函数A内部的局部变量a不能被A以外的函数访问到，只能被A内部的子函数B访问到，这是由于JavaScript的链式作用域结构导致的，既然只有内部函数B才可以访问到函数A中的局部变量a，那么我们只需要把函数B作为函数A的返回值，就可以在函数A外部访问它的局部变量a！ 其中函数B就是闭包。 由上可知： 闭包就是一个函数。 闭包作用：访问其他函数内部的局部变量。 所以，在函数内部创建子函数，最后返回子函数，这是平常开发创建闭包最常见的方式。 面向对象中使用闭包读取设置私有属性 1234567891011121314151617181920212223 //使用构造函数创建一个Person class Person&#123;&#125;function Person(name,age)&#123; this.name = name; // this公有属性 var age = age; // var 私有属性 //通过一个公有的函数来访问其私有属性 this.getAge = function()&#123; return &quot;age:&quot;+age; &#125; //通过一个闭包函数来修改其私有属性 this.setAge = function(newage)&#123; age = newage; &#125;&#125;//实例化一个实例对象var p1 = new Person(&apos;大锤&apos;,18);console.log(p1.age); // undefined 不能直接读取私有属性console.log( p1.getAge() ); // 18p1.setAge(&apos;38&apos;);console.log( p1.getAge() ); // 38 由于var定义的属性是私有属性（局部变量），因此只能通过闭包函数去读取。 注意，由于闭包可以访问函数内的局部变量，所以此变量是不会被垃圾回收机制回收的，使用不当还可能造成会内存泄漏（未能释放已经不再使用的内存）。 继承 回顾创建对象的方式 通过new Object()或{}，两种本质是一样的，后者是前者的语法糖形式（简写形式）。 工厂方式创建对象 构造函数和原型对象（定理） 构造函数有个prototype属性，指向原型对象 原型对象有个constructor属性，指向构造函数本身。 通过构造函数new出来的对象，有个隐形的属性proto属性，指向原型对象。 call和apply 1、call和apply作用 执行函数并改变函数中的this指向。 2、call和apply的区别 语法如下所示：12fuName.call(obj,实参数1，实参数2...) fuName.apply(obj, [ 参数1，参数2..... ] ) 说明：使用对象obj伪造函数fuName中的this，于是函数fuName中的this都被obj对象伪造了。 相同点：都是改变函数内this的指向。 不同点：参数传递的形式不一样。 call参数是一个一个传，需要传递几个就需要看函数需要几个形参。 apply是传递一个参数数组，如果apply是使用在某个函数内,则参数数组可以使用类数组arguments进行代替。 call和apply继承代码实现 1、通过call或者apply继承的思想： 在子类的构造函数中，使用call或apply去伪造父类构造函数中的this，把父类构造函数中的属性添加到子类对象的自身空间中。 3、 call或apply继承带来的缺点 通过call或apply只能会把父类构造函数中定义的属性复制一份到子类对象自身空间中，但是无法继承到父类原型对象上面的属性。 解决办法： 通过原型继承来实现，可以继承父类原型对象中的属性。 通过原型对象继承 1、原型对象继承的核心思想 用父类对象重写子类原型对象。核心代码如下 1子类.prototype = new 父类() 2、代码实现即内存空间图解 3、通过原型继承带来的问题 当子类的某个对象对引用类型属性如数组添加一个值的时候，实质上，我们是把此值添加在子类原型对象的属性中，这样会造成所有子类对象对此属性的读取，这是我们不允许的。 我们希望，每个子类自身空间中都独有一份引用属性，则当子类对象修改的时候只会影响当前对象，对其他对象没有任何影响。 解决办法：通过混合继承。 通过伪造继承+原型继承混合起来，就可以解决伪造继承和原型继承单独使用带来的问题。 混合继承（伪造+原型对象) 1、伪造继承和原型继承分别带来的问题 伪造继承带来的问题：只能将父类构造函数中的属性放到子类对象的自身空间中，但是无法继承父类原型对象上面的属性。 原型继承带来的问题：子类对象只能继承父类原型对象上面的属性，但是无法把父类构造函数中的属性放到自身空间中。 2、通过伪造和原型对象混合继承的核心思想： 通过伪造继承,把父类构造函数中的属性添加到子类对象的自身空间中 通过原型继承,继承到父类原型上面的属性 最后把他们两者组合起来即可（形成互补） 如： 伪造继承：它会喝酒，但不会抽烟原型继承：不会喝酒，但会抽烟组合起来，可实现又会抽烟又会抽烟。 （ps:少抽烟喝酒，年轻人身体最重要） 3、代码实现 通过es6创建类和继承 class 定义类 extends 继承 1234567891011121314151617181920212223242526272829//创建父类Parentclass Parent&#123; //构造函数(不要加关键字function) constructor(name,age)&#123; this.name = name; this.age = age; &#125; getName()&#123; return this.name; &#125;&#125;//创建子类Child继承Parentclass Child extends Parent&#123; //构造函数(不要加关键字function) constructor(name,age,email)&#123; //执行父类的构造函数，继承name和age属性，到子类对象自身空间中 super(name,age); this.email = email; &#125; getAge()&#123; return this.age; &#125;&#125;//实例化子类对象var c = new Child(&apos;zs&apos;,33,&apos;zs@qq.com&apos;)console.log( c.getAge() ); // 33console.log( c.getName() ); // zs class和extends底层还是通过原型对象来实现的，其是原型对象的一种语法糖形式（简化写法） 继承小结 使用混合继承（伪造+原型对象)要点： 利用伪造call或apply继承父类构造函数中的属性到子类的自身空间中 利用原型对象继承父类原型对象上的属性 最终将a、b两种组合起来即可实现完整的继承。 继承原型链终极图解 在js继承体系中，最终都是通过对象的proto找到其对应的原型对象，最终实现继承。 注意： 函数没有返回值，默认返回undefined函数名.length 查看最少传递的实参个数。","categories":[],"tags":[{"name":"闭包","slug":"闭包","permalink":"http://yoursite.com/tags/闭包/"}]},{"title":"设计者模式","slug":"myblog","date":"2019-06-03T08:54:45.000Z","updated":"2019-06-05T09:07:25.546Z","comments":true,"path":"2019/06/03/myblog/","link":"","permalink":"http://yoursite.com/2019/06/03/myblog/","excerpt":"","text":"设计者模式 设计模式什么是设计模式 设计模式 什么是设计模式设计模式（Design patern）是一套被反复使用、思想成熟、经过无数实战设计经验的总结。大白话：设计模式就是在特定场景解决特定的问题，如果某种办法都可以解决问题，我们就可以把这种通用的解决方法称之为模式。在代码中，其核心是代码的整体结构和解决问题的思路。 设计模式作用 代码复用 方便扩展 增加可维护性 其中设计模式最重要的一个原则是开闭原则，即对扩展 ，对修改关闭。 单例模式概念：一个类只产生唯一的一个实例。因为在许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。 作用：节省内存。 应用场景：如商城系统中购车对象是单例的。 示例1：创建单例对象1234567891011function Person()&#123; //核心：通过一个实例属性，来判断之前是否创建过//没有创建，则创建对象 if( !Person.instance )&#123; Person.instance = &#123;&#125;; &#125;//为真，说明有这个属性，则直接返回实例对象 return Person.instance; &#125; var p1 = Person(); var p2 = Person(); console.log(p1 === p2); // true 内存空间地址相同的。` 工厂模式（构造函数模式） 生活中的工厂就是批量生产产品的地方。如一个服装工厂,可以生产衣服和裤子等。在代码中，工厂模式就是是由一个方法来决定到底要创建哪个类的实例。如：宝马工厂创建x1和x5品牌汽车 1234567891011121314var factory = &#123;&#125;;factory.createProductA = function()&#123; console.log(&apos;A&apos;);&#125;factory.createProductB = function()&#123; console.log(&apos;B&apos;);&#125;factory.createProductC = function()&#123; console.log(&apos;C&apos;);&#125;factory.create = function(type)&#123; return new factory[type];&#125;//测试factory.create(&apos;createProductA&apos;); 什么时候使用工厂模式，分为以下几种情景： 对象的构建较复杂生成大量不同对象的时候 策略模式 每个问题都提前想好对应的解决方案（一种映射关系），而不是遇到问题再去手忙脚乱的想办法。 核心思想：提前想好策略. 代码：计算员工工资（工资由等级和底薪构成） 1234567891011121314151617//封装的策略算法var strategies = &#123; function (salary) &#123; return salary * 4; &#125;, function (salary) &#123; return salary * 3; &#125;, function (salary) &#123; return salary * 2; &#125; &#125;;//具体的计算方法 var calculateBonus = function (level, salary) &#123; return strategies[level](salary); &#125;; console.log(calculateBonus(&apos;S&apos;, 1000)); // 4000 console.log(calculateBonus(&apos;A&apos;, 4000)); // 12000 使用策略模式重构代码，在实际开发中，可以消除程序中大片的条件分支语句。 适配器模式 通俗理解：比如苹果插座是三孔的,这时候我们想要充电,但是并没有三孔的插头,这时候我们就需要适配器转换一下,这样我们就可以充电的,这就是适配器模式解决问题的场景。 适配器模式侧重点在于转换接口,解决不兼容问题代码体现：在前端开发中，如果后台接口返回的是一个对象格式，但是我们的需求是需要数组格式，怎么办？（前后端开始撕逼了…）那么这种问题，我们前端完全可以按照适配器的思想去定义一个方法来实现对象到数组的转换。代码如下： 1234567891011// 适配器模式// obj对象转换为数组function objToArray(obj) &#123; var arr = []; //新数组for (var i in obj) &#123; arr.push(obj[i]);&#125; return arr;&#125;// 创建一个对象var obj = &#123;name: &apos;大锤&apos;,age: 18,sex: &apos;男&apos;&#125;// 适配器方式转换console.log(objToArray(obj)); // [&amp;quot;大锤&amp;quot;, 18, &amp;quot;男&amp;quot;] 观察者模式 观察者模式也称之为发布订阅模式模式。 它定义了一种一对多的关系，让多个观察者对象同时监听某一个发布者对象，这个发布者对象的状态发生改变时就会通知所有的观察者对象。 如：多个人订阅微信公众号，微信公众号发布了文章，他们都可以收到。其中微信公众号就是发布者，其他人就是订阅者。代码:123456789101112131415161718192021222324252627282930313233//（发布者，微信公众号）被观察者function ObServer()&#123;//存储所有的订阅者（每一个订阅者是一个函数fn） this.funcs = [];&#125;ObServer.prototype.subscribe = function(fn)&#123; this.funcs.push(fn);&#125;ObServer.prototype.unsubscribe = function(fn)&#123; this.funcs = this.funcs.filter (function(item)&#123; if(item!==fn)&#123; return item; &#125; &#125;)&#125;ObServer.prototype.notify = function(msg)&#123; this.funcs.forEach(function(item)&#123; item(msg); &#125;);&#125;var o = new ObServer();var fn1 = function(msg)&#123; console.log(&apos;fn1收到通知了：&apos;+msg);&#125;var fn2 = function(msg)&#123; console.log(&apos;fn2收到通知了：&apos;+msg);&#125;o.subscribe(fn1);o.subscribe(fn2);o.notify(&apos;发布文章1&apos;);o.unsubscribe(fn2);console.log(o.funcs);o.notify(&apos;发布文章2&apos;)","categories":[{"name":"web前端","slug":"web前端","permalink":"http://yoursite.com/categories/web前端/"},{"name":"js","slug":"web前端/js","permalink":"http://yoursite.com/categories/web前端/js/"}],"tags":[{"name":"设计者模式","slug":"设计者模式","permalink":"http://yoursite.com/tags/设计者模式/"}]}]}